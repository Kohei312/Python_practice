## 深さ優先探索

def deep_first_search(H, W, S):
    """
    H: 高さ
    W: 幅
    S: 計算対象となる文字列のリスト
    """
    # write code here
    def dfs(x, y): ## 現在位置からの動き方. gまで到達できたらTrueを返す
        if any((x < 0, y < 0, x >= W, y >= H)): # 枠外へはみ出さないように定義
            return False
        if S[y][x] == '#': # #にぶつかった(文字列のリストから、#を取り出した)場合 => 失敗
            return False
        if S[y][x] == 'g': # gにぶつかった(文字列のリストから、gを取り出した)場合 => 成功
            return True
        tmp_y = S[y] # ある行が、 .... だった場合 
        tmp_y = tmp_y[:x] + "#" + tmp_y[(x+1):] # ..#. のように変換される
        S[y] = tmp_y
        return dfs(x-1, y) |  dfs(x+1, y) | dfs(x, y-1) | dfs(x, y+1) # ここで再探索.どれか1つでもTrueなら、Trueがreturnされる.
    
    for i in range(H):
        for j in range(W):
            if S[i][j] == "s":
                if dfs(i, j):
                    print("Yes")
                else:
                    print("No")

# spos[0]の場合
# s####
# ....#
# #####
# #...g

# spos[1]の場合
# ...s
# ....
# ....
# .g..

# spos[2]の場合
# s.........
# ##########
# #.......#.
# #..####.#.
# ##....#.#.
# #####.#.#.
# g.#.#.#.#.
# #.#.#.#.#.
# ###.#.#.#.
# #.....#...

# spot[3]
# s.........
# #########.
# #.......#.
# #..####.#.
# ##....#.#.
# #####.#.#.
# g.#.#.#.#.
# #.#.#.#.#.
# #.#.#.#.#.
# #.....#...

# spot[4]
# s..####..g


Hs = [4, 4, 10, 10, 1]
Ws = [5, 4, 10, 10, 10]
spots = [
    ['s####', '....#', '#####', '#...g'],
    ['...s', '....', '....', '.g..'],
    ['s.........', '#########.', '#.......#.', '#..####.#.', '##....#.#.', '#####.#.#.', 'g.#.#.#.#.', '#.#.#.#.#.', '###.#.#.#.', '#.....#...'],
    ['s.........', '#########.', '#.......#.', '#..####.#.', '##....#.#.', '#####.#.#.', 'g.#.#.#.#.', '#.#.#.#.#.', '#.#.#.#.#.', '#.....#...'],
    ['s..####..g']
]
deep_first_search(Hs[0], Ws[0], spots[0]) # No
deep_first_search(Hs[1], Ws[1], spots[1]) # Yes
deep_first_search(Hs[2], Ws[2], spots[2]) # No
deep_first_search(Hs[3], Ws[3], spots[3]) # Yes
deep_first_search(Hs[4], Ws[4], spots[4]) # No